#fragment push getters
impl<T: AsRef<[u8]>> {struct_name}<T> {{
{fields}
#fragment push fixed
    /// Raw field getter for {info}.
    ///
    /// {description}
    pub fn get_raw_{name}(&self) -> {raw_type} {{
{fragment}
#fragment push bit.aligned
        unsafe {{ {codec}::read_aligned::<{raw_type}, {bit_offset}, {bit_size}>(self.data.as_ref().get_unchecked({start}..{end})) }}
#fragment pop
#fragment push bit.unaligned
        unsafe {{ {codec}::read_unaligned::<{raw_type}, {bit_offset}, {bit_size}>(self.data.as_ref().get_unchecked({start}..{end})) }}
#fragment pop
#fragment push byte.aligned
        unsafe {{ {codec}::read_aligned::<{raw_type}>(self.data.as_ref().get_unchecked({start}..{end})) }}
#fragment pop
#fragment push byte.unaligned
        unsafe {{ {codec}::read_unaligned::<{raw_type}>(self.data.as_ref().get_unchecked({start}..{end})) }}
#fragment pop
    }}
#fragment pop
#fragment push array
    /// Immutable access to {info}.
    ///
    /// {description}
    pub fn get_{name}(&self) -> bp3d_proto::codec::ArrayCodec<&[u8], {raw_type}, {codec}, {bit_size}> {{
        unsafe {{ bp3d_proto::codec::ArrayCodec::new(self.data.as_ref().get_unchecked({start}..{end})) }}
    }}
#fragment pop
#fragment push struct
    /// Immutable access to {info}.
    ///
    /// {description}
    pub fn get_{name}(&self) -> {type_name}<&[u8]> {{
        unsafe {{ {type_name}::new_unchecked(self.data.as_ref().get_unchecked({start}..{end})) }}
    }}
#fragment pop
#fragment push view_float
    /// Field getter for {info}.
    ///
    /// {description}
    pub fn get_{name}(&self) -> {view_type} {{
        let raw_value = self.get_raw_{name}() as {view_type};
        raw_value * {a} + {b}
    }}
#fragment pop
#fragment push view_enum
    /// Field getter for {info}.
    ///
    /// {description}
    pub fn get_{name}(&self) -> Option<{view_type}> {{
        {view_type}::from_raw(self.get_raw_{name}())
    }}
#fragment pop
#fragment push view_transmute
    /// Field getter for {info}.
    ///
    /// {description}
    pub fn get_{name}(&self) -> {view_type} {{
{fragment}
#fragment push bool
        self.get_raw_{name}() != 0
#fragment pop
#fragment push other
        bp3d_proto::transmute!(<{raw_type}, {view_type}>(self.get_raw_{name}()))
#fragment pop
    }}
#fragment pop
#fragment push view_signed
    /// Field getter for {info}.
    ///
    /// {description}
    pub fn get_{name}(&self) -> {view_type} {{
        let raw_value = self.get_raw_{name}();
        if raw_value > {max_positive} {{
            -((((!raw_value) & {max_positive}) + 1) as {view_type})
        }} else {{
            (raw_value & {max_positive}) as {view_type}
        }}
    }}
#fragment pop
#fragment push view_none
    /// Field getter for {info}.
    ///
    /// {description}
    pub fn get_{name}(&self) -> {view_type} {{
        self.get_raw_{name}()
    }}
#fragment pop
}}
#fragment pop

#fragment push setters
impl<T: AsMut<[u8]>> {struct_name}<T> {{
{fields}
#fragment push fixed
    /// Raw field setter for {info}.
    ///
    /// {description}
    pub fn set_raw_{name}(&mut self, value: {raw_type}) {{
{fragment}
#fragment push bit.aligned
        unsafe {{ {codec}::write_aligned::<{raw_type}, {bit_offset}, {bit_size}>(self.data.as_mut().get_unchecked_mut({start}..{end}), value) }}
#fragment pop
#fragment push bit.unaligned
        unsafe {{ {codec}::write_unaligned::<{raw_type}, {bit_offset}, {bit_size}>(self.data.as_mut().get_unchecked_mut({start}..{end}), value) }}
#fragment pop
#fragment push byte.aligned
        unsafe {{ {codec}::write_aligned::<{raw_type}>(self.data.as_mut().get_unchecked_mut({start}..{end}), value) }}
#fragment pop
#fragment push byte.unaligned
        unsafe {{ {codec}::write_unaligned::<{raw_type}>(self.data.as_mut().get_unchecked_mut({start}..{end}), value) }}
#fragment pop
    }}
#fragment pop
#fragment push array
    /// Mutable access to {info}.
    ///
    /// {description}
    pub fn get_{name}_mut(&mut self) -> bp3d_proto::codec::ArrayCodec<&mut [u8], {raw_type}, {codec}, {bit_size}> {{
        unsafe {{ bp3d_proto::codec::ArrayCodec::new(self.data.as_mut().get_unchecked_mut({start}..{end})) }}
    }}
#fragment pop
#fragment push struct
    /// Mutable access to {info}.
    ///
    /// {description}
    pub fn get_{name}_mut(&mut self) -> {type_name}<&mut [u8]> {{
        unsafe {{ {type_name}::new_unchecked(self.data.as_mut().get_unchecked_mut({start}..{end})) }}
    }}
#fragment pop
#fragment push view_float
    /// Field setter for {info}.
    ///
    /// {description}
    pub fn set_{name}(&mut self, value: {view_type}) -> &mut Self {{
        let raw_value = value * {a_inv} + {b_inv};
        self.set_raw_{name}(raw_value as {raw_type});
        self
    }}
#fragment pop
#fragment push view_enum
    /// Field setter for {info}.
    ///
    /// {description}
    pub fn set_{name}(&mut self, value: {view_type}) -> &mut Self {{
        self.set_raw_{name}(value.into_raw());
        self
    }}
#fragment pop
#fragment push view_transmute
    /// Field setter for {info}.
    ///
    /// {description}
    pub fn set_{name}(&mut self, value: {view_type}) -> &mut Self {{
{fragment}
#fragment push bool
        if value {{
            self.set_raw_{name}(1);
        }} else {{
            self.set_raw_{name}(0);
        }}
#fragment pop
#fragment push other
        self.set_raw_{name}(bp3d_proto::transmute!(<{view_type}, {raw_type}>(value)));
#fragment pop
        self
    }}
#fragment pop
#fragment push view_none
    /// Field setter for {info}.
    ///
    /// {description}
    pub fn set_{name}(&mut self, value: {view_type}) -> &mut Self {{
        self.set_raw_{name}(value);
        self
    }}
#fragment pop
}}
#fragment pop
