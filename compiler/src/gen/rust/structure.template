#fragment push new
impl<T> {name}<T> {{
    pub fn new(data: T) -> Self {{
        Self {{ data }}
    }}

    pub fn into_inner(self) -> T {{
        self.data
    }}
}}

impl {name}<[u8; {byte_size}]> {{
    pub fn new_on_stack() -> Self {{
        Self {{ data: [0; {byte_size}] }}
    }}
}}

impl<T> From<T> for {name}<T> {{
    fn from(data: T) -> Self {{
        Self {{ data }}
    }}
}}

impl<'a, T: AsRef<[u8]>> {name}<T> {{
    pub fn to_ref(&'a self) -> {name}<&'a [u8]> {{
        {name} {{ data: self.data.as_ref() }}
    }}
}}

impl<T: AsRef<[u8]>> {name}<T> {{
    pub fn copy_on_stack(&self) -> {name}<[u8; {byte_size}]> {{
        if self.data.as_ref().len() < {byte_size} {{
            panic!("attempt to copy a too small buffer");
        }}
        use std::mem::MaybeUninit;
        let mut data: [MaybeUninit<u8>; {byte_size}] = unsafe {{ MaybeUninit::uninit().assume_init() }};
        #[allow(clippy::missing_transmute_annotations)]
        unsafe {{
            std::ptr::copy_nonoverlapping(self.data.as_ref().as_ptr(), std::mem::transmute(data.as_mut_ptr()), {byte_size});
        }}
        #[allow(clippy::missing_transmute_annotations)]
        {name} {{ data: unsafe {{ std::mem::transmute(data) }} }}
    }}
}}

impl<'a, T: AsMut<[u8]>> {name}<T> {{
    pub fn to_mut(&'a mut self) -> {name}<&'a mut [u8]> {{
        {name} {{ data: self.data.as_mut() }}
    }}
}}

impl<T: AsRef<[u8]>> AsRef<[u8]> for {name}<T> {{
    fn as_ref(&self) -> &[u8] {{
        self.data.as_ref()
    }}
}}

impl<T: AsMut<[u8]>> AsMut<[u8]> for {name}<T> {{
    fn as_mut(&mut self) -> &mut [u8] {{
        self.data.as_mut()
    }}
}}

pub const SIZE_{name:to_screaming_case}: usize = {byte_size};
#fragment pop

#fragment push decl
#[derive(Copy, Clone, Default, Debug)]
pub struct {name}<T> {{
    data: T
}}
#fragment pop

#fragment push fixed_size
impl<T> bp3d_proto::util::FixedSize for {name}<T> {{
    const SIZE: usize = {byte_size};
}}
#fragment pop

#fragment push write_to
impl<'a> bp3d_proto::message::WriteTo for {name}<&'a [u8]> {{
    type Input<'b> = Self;

    fn write_to<W: std::io::Write>(input: &Self, mut out: W) -> bp3d_proto::message::Result<()> {{
        out.write_all(&input.data[..<Self as bp3d_proto::util::FixedSize>::SIZE])?;
        Ok(())
    }}
}}
#fragment pop

#fragment push write_to_async
impl<'a> bp3d_proto::message::WriteToAsync for {name}<&'a [u8]> {{
    async fn write_to_async<W: tokio::io::AsyncWriteExt + Unpin>(input: &Self, mut out: W) -> bp3d_proto::message::Result<()> {{
        out.write_all(&input.data[..<Self as bp3d_proto::util::FixedSize>::SIZE]).await?;
        Ok(())
    }}
}}
#fragment pop

#fragment push from_slice
impl<'a> bp3d_proto::message::FromSlice<'a> for {name}<&'a [u8]> {{
    type Output = Self;

    fn from_slice(slice: &'a [u8]) -> bp3d_proto::message::Result<bp3d_proto::message::Message<Self>> {{
        if slice.len() < <Self as bp3d_proto::util::FixedSize>::SIZE {{
            Err(bp3d_proto::message::Error::Truncated)
        }} else {{
            Ok(bp3d_proto::message::Message::new(<Self as bp3d_proto::util::FixedSize>::SIZE, Self::new(&slice[..<Self as bp3d_proto::util::FixedSize>::SIZE])))
        }}
    }}
}}
#fragment pop
