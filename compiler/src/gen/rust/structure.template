#fragment push new
#[allow(dead_code)]
impl<T> {name}<T> {{
    /// Returns the underlying wrapped data.
    pub fn into_inner(self) -> T {{
        self.data
    }}
}}

#[allow(dead_code)]
impl {name}<[u8; {byte_size}]> {{
    /// Allocates a new default initialized instance of this structure onto the stack.
    pub fn new() -> Self {{
        Self {{ data: [0; {byte_size}] }}
    }}
}}

#[allow(dead_code)]
impl<'a, T: AsRef<[u8]>> {name}<T> {{
    /// Converts this structure to an immutable reference for use with the message/union system.
    ///
    /// This gets a new instance of this structure by immutably referencing the data buffer contained within itself.
    pub fn to_ref(&'a self) -> {name}<&'a [u8]> {{
        {name} {{ data: self.data.as_ref() }}
    }}
}}

impl<T: AsRef<[u8]>> AsRef<[u8]> for {name}<T> {{
    fn as_ref(&self) -> &[u8] {{
        self.data.as_ref()
    }}
}}

impl<T: AsMut<[u8]>> AsMut<[u8]> for {name}<T> {{
    fn as_mut(&mut self) -> &mut [u8] {{
        self.data.as_mut()
    }}
}}

impl<T: AsRef<[u8]>> bp3d_proto::util::Wrap<T> for {name}<T> {{
    unsafe fn wrap_unchecked(data: T) -> Self {{
        Self {{ data }}
    }}
}}

#[allow(dead_code)]
/// The size of the {name} structure.
pub const SIZE_{name:to_screaming_case}: usize = {byte_size};
#fragment pop

#fragment push to_mut
impl<'a, T: AsMut<[u8]>> {name}<T> {{
    /// Converts this structure to a mutable reference for use with the message/union system.
    ///
    /// This gets a new instance of this structure by mutably referencing the data buffer contained within itself.
    pub fn to_mut(&'a mut self) -> {name}<&'a mut [u8]> {{
        {name} {{ data: self.data.as_mut() }}
    }}
}}
#fragment pop

#fragment push dupe
impl<T: AsRef<[u8]>> {name}<T> {{
    /// Duplicates this structure onto the stack.
    ///
    /// WARNING: Unlike Copy/Clone this will ALWAYS allocate a new buffer on the stack, similarly to the
    /// [new](Self::new) function.
    pub fn dupe(&self) -> {name}<[u8; {byte_size}]> {{
        use std::mem::MaybeUninit;
        let mut data: [MaybeUninit<u8>; {byte_size}] = unsafe {{ MaybeUninit::uninit().assume_init() }};
        unsafe {{
            std::ptr::copy_nonoverlapping(self.data.as_ref().as_ptr(), std::mem::transmute(data.as_mut_ptr()), {byte_size});
            {name} {{ data: std::mem::transmute::<[MaybeUninit<u8>; {byte_size}], [u8; {byte_size}]>(data) }}
        }}
    }}
}}
#fragment pop

#fragment push decl
/// Definition for the {name} structure.
///
/// {struct_description}
#[derive(Copy, Clone, Default, Debug)]
pub struct {name}<T> {{
    data: T
}}
#fragment pop

#fragment push fixed_size
impl<T> bp3d_proto::util::Size for {name}<T> {{
    const SIZE: usize = {byte_size};
}}
#fragment pop

#fragment push write_to
impl<'a> bp3d_proto::message::WriteTo for {name}<&'a [u8]> {{
    type Input<'b> = Self;

    fn write_to<W: std::io::Write>(input: &Self, mut out: W) -> bp3d_proto::message::Result<()> {{
        out.write_all(&input.data[..{byte_size}])?;
        Ok(())
    }}
}}
#fragment pop

#fragment push write_to_async
impl<'a> bp3d_proto::message::WriteToAsync for {name}<&'a [u8]> {{
    async fn write_to_async<W: tokio::io::AsyncWriteExt + Unpin>(input: &Self::Input<'_>, mut out: W) -> bp3d_proto::message::Result<()> {{
        out.write_all(&input.data[..{byte_size}]).await?;
        Ok(())
    }}
}}
#fragment pop

#fragment push from_bytes
impl<'a> bp3d_proto::message::FromBytes<'a> for {name}<&'a [u8]> {{
    type Output = Self;

    fn from_bytes(bytes: &'a [u8]) -> bp3d_proto::message::Result<bp3d_proto::message::Message<Self>> {{
        if bytes.len() < {byte_size} {{
            Err(bp3d_proto::message::Error::Truncated)
        }} else {{
            Ok(bp3d_proto::message::Message::new({byte_size}, Self {{ data: &bytes[..{byte_size}] }}))
        }}
    }}
}}
#fragment pop
